# .github/workflows/windows-build.yml
# Builds on Windows using MSYS2, automatically detects DLL dependencies using ntldd,
# packages artifacts, and uploads.

name: Build Windows Release

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build-windows:
    runs-on: windows-latest
    defaults:
      run:
        shell: msys2 {0}

    steps:
    # Step 1: Checkout repository
    - name: Checkout repository
      uses: actions/checkout@v4
      # with:
      #   submodules: 'recursive'

    # Step 2: Set up MSYS2 environment & Install Dependencies
    - name: Set up MSYS2
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: >-
          git
          mingw-w64-x86_64-toolchain
          mingw-w64-x86_64-meson
          mingw-w64-x86_64-ninja
          mingw-w64-x86_64-python
          mingw-w64-x86_64-pkgconf
          mingw-w64-x86_64-gtk4
          mingw-w64-x86_64-libadwaita
          mingw-w64-x86_64-json-glib
          mingw-w64-x86_64-gettext
          mingw-w64-x86_64-desktop-file-utils
          mingw-w64-x86_64-appstream
          mingw-w64-x86_64-ntldd

    # Step 3: Configure build
    - name: Configure build
      run: meson setup build --prefix=/mingw64 --buildtype=release

    # Step 4: Compile project
    - name: Compile project
      run: ninja -C build

    # Step 5: Install project
    - name: Install project
      # Let the workflow fail if installation fails (removed || echo)
      run: ninja -C build install

    # Step 6: Analyze Dependencies using ntldd
    - name: Analyze Dependencies
      run: |
        EXE_PATH="/mingw64/bin/gtk-crusader-village.exe"
        DLL_LIST_FILE="dll_list.txt" # File to store needed DLL paths

        echo "Running ntldd on ${EXE_PATH}..."
        # Run ntldd, resolve relative paths (-R), grep for DLLs inside the mingw64 prefix,
        # use awk to extract the full path (usually 3rd field), sort uniquely.
        # Filter out the exe itself and common system DLLs if necessary (though grep /mingw64/ should handle most)
        ntldd -R "$EXE_PATH" | grep '/mingw64/bin/' | awk '{print $3}' | grep -v "$EXE_PATH" | sort -u > "$DLL_LIST_FILE"

        echo "Found dependent DLLs from /mingw64/bin:"
        cat "$DLL_LIST_FILE"
      # Make the DLL list available to the next step
      id: deps 

    # Step 7: Prepare artifact directory using dynamic DLL list
    - name: Prepare artifact directory
      run: |
        INSTALL_DIR="/mingw64"
        DEST_DIR="artifact"
        DLL_LIST_FILE="dll_list.txt" # File containing needed DLL paths from previous step

        echo "Creating destination directories..."
        mkdir -p "${DEST_DIR}/bin"
        mkdir -p "${DEST_DIR}/share/icons/hicolor/scalable/apps"
        mkdir -p "${DEST_DIR}/share/icons/hicolor/symbolic/apps"
        mkdir -p "${DEST_DIR}/share/glib-2.0/schemas"
        mkdir -p "${DEST_DIR}/share/locale"
        mkdir -p "${DEST_DIR}/share/metainfo"
        mkdir -p "${DEST_DIR}/share/applications"
        mkdir -p "${DEST_DIR}/share/dbus-1/services"

        echo "Copying executable..."
        cp --verbose "${INSTALL_DIR}/bin/gtk-crusader-village.exe" "${DEST_DIR}/bin/"

        echo "Copying detected DLLs from ${DLL_LIST_FILE}..."
        if [ -f "$DLL_LIST_FILE" ]; then
          while IFS= read -r dll_path; do
            if [ -f "$dll_path" ]; then
              echo "Copying $dll_path"
              cp --verbose "$dll_path" "${DEST_DIR}/bin/"
            else
              echo "Warning: DLL listed by ntldd not found: $dll_path"
            fi
          done < "$DLL_LIST_FILE"
        else
          echo "Warning: ${DLL_LIST_FILE} not found. Cannot copy DLLs automatically."
        fi

        # --- Copying data files (remains the same) ---
        echo "Copying data files..."
        cp --verbose "${INSTALL_DIR}/share/glib-2.0/schemas/"*.xml "${DEST_DIR}/share/glib-2.0/schemas/" 2>/dev/null || echo "Warning: gschema files not found."
        cp --verbose "${INSTALL_DIR}/share/icons/hicolor/scalable/apps/"*.svg "${DEST_DIR}/share/icons/hicolor/scalable/apps/" 2>/dev/null || echo "Warning: Scalable icon not found."
        cp --verbose "${INSTALL_DIR}/share/icons/hicolor/symbolic/apps/"*.svg "${DEST_DIR}/share/icons/hicolor/symbolic/apps/" 2>/dev/null || echo "Warning: Symbolic icon not found."
        cp --verbose "${INSTALL_DIR}/share/metainfo/"*.xml "${DEST_DIR}/share/metainfo/" 2>/dev/null || echo "Warning: metainfo file not found."
        cp --verbose "${INSTALL_DIR}/share/applications/"*.desktop "${DEST_DIR}/share/applications/" 2>/dev/null || echo "Warning: .desktop file not found."
        cp --verbose "${INSTALL_DIR}/share/dbus-1/services/"*.service "${DEST_DIR}/share/dbus-1/services/" 2>/dev/null || echo "Warning: .service file not found."

        echo "Copying locale files..."
        if [ -d "${INSTALL_DIR}/share/locale" ]; then
          for langdir in "${INSTALL_DIR}"/share/locale/*; do
            lang=$(basename "$langdir")
            if [[ "$lang" =~ ^[a-z]{2}(_[A-Z]{2})?$ ]]; then
              if [ -f "$langdir/LC_MESSAGES/gtk-crusader-village.mo" ]; then
                mkdir -p "${DEST_DIR}/share/locale/$lang/LC_MESSAGES"
                cp "$langdir/LC_MESSAGES/gtk-crusader-village.mo" "${DEST_DIR}/share/locale/$lang/LC_MESSAGES/"
              fi
            fi
          done
        fi
        # --- End copying data files ---

    # Step 8: Upload the artifact (action zips the directory)
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: gtk-crusader-village-windows-x64
        path: artifact # Upload the contents of the 'artifact' directory

    # Optional: Create Release and Upload Asset (uncomment and adapt if you use tags for releases)
    # - name: Create Release
    #   if: startsWith(github.ref, 'refs/tags/')
    #   id: create_release
    #   uses: actions/create-release@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     tag_name: ${{ github.ref_name }}
    #     release_name: Release ${{ github.ref_name }}
    #     draft: false
    #     prerelease: false # Set to true if it's a pre-release
    #
    # - name: Upload Release Asset
    #   if: startsWith(github.ref, 'refs/tags/')
    #   uses: actions/upload-release-asset@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     upload_url: ${{ steps.create_release.outputs.upload_url }}
    #     asset_path: ./gtk-crusader-village-windows-x64.zip
    #     asset_name: gtk-crusader-village-windows-x64.zip
    #     asset_content_type: application/zip
