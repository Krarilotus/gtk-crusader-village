# .github/workflows/windows-build.yml
# Builds on Windows using MSYS2, automatically detects DLL dependencies using ntldd,
# packages artifacts, and uploads.

name: Build Windows Release

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build-windows:
    runs-on: windows-latest
    defaults:
      run:
        shell: msys2 {0}

    steps:
    # Step 1: Checkout repository
    - name: Checkout repository
      uses: actions/checkout@v4
      # with:
      #   submodules: 'recursive'

    # Step 2: Set up MSYS2 environment & Install Dependencies
    - name: Set up MSYS2
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: >-
          git
          mingw-w64-x86_64-toolchain
          mingw-w64-x86_64-meson
          mingw-w64-x86_64-ninja
          mingw-w64-x86_64-python
          mingw-w64-x86_64-pkgconf
          mingw-w64-x86_64-gtk4
          mingw-w64-x86_64-libadwaita
          mingw-w64-x86_64-json-glib
          mingw-w64-x86_64-gettext
          mingw-w64-x86_64-desktop-file-utils
          mingw-w64-x86_64-appstream
          mingw-w64-x86_64-ntldd
          mingw-w64-x86_64-hicolor-icon-theme
          mingw-w64-x86_64-librsvg
          mingw-w64-x86_64-adwaita-icon-theme

    # Step 3: Configure build
    - name: Configure build
      run: meson setup build --prefix=/mingw64 --buildtype=release

    # Step 4: Compile project
    - name: Compile project
      run: ninja -C build

    # Step 5: Install project
    - name: Install project
      # Let the workflow fail if installation fails (removed || echo)
      run: ninja -C build install

    # Step 6: Analyze Dependencies using ntldd (Corrected grep pattern)
    - name: Analyze Dependencies
      run: |
        EXE_PATH="/mingw64/bin/gtk-crusader-village.exe"
        DLL_LIST_FILE="dll_list.txt"
        NTLDD_OUTPUT_FILE="ntldd_output.log"
        NTLDD_ERROR_FILE="ntldd_error.log"
        # Intermediate files for pipeline steps (optional now, but keep for debug)
        STEP1_OUT="pipe_step1.log"
        STEP2_OUT="pipe_step2.log"
        STEP3_OUT="pipe_step3.log"
        STEP4_OUT="pipe_step4.log"
    
        echo "--- Debugging ntldd & Pipeline ---"
        echo "Checking if executable exists at ${EXE_PATH}:"
        ls -l "$EXE_PATH" || { echo "*** EXECUTABLE ${EXE_PATH} not found! ***"; exit 1; }
    
        echo "Attempting to run ntldd -R ${EXE_PATH}..."
        ntldd -R "$EXE_PATH" > "$NTLDD_OUTPUT_FILE" 2> "$NTLDD_ERROR_FILE"
        NTLDD_EXIT_CODE=$?
        echo "ntldd exit code: ${NTLDD_EXIT_CODE}"
        echo "--- ntldd stderr (${NTLDD_ERROR_FILE}): ---"; cat "$NTLDD_ERROR_FILE" || echo "  (No stderr)"; echo "--- End ntldd stderr ---"
        if [ ${NTLDD_EXIT_CODE} -ne 0 ]; then
          echo "ntldd command failed. Exiting."
          exit ${NTLDD_EXIT_CODE}
        fi
        # Print stdout for reference even if parsing fails later
        echo "--- ntldd stdout (${NTLDD_OUTPUT_FILE}): ---"; cat "$NTLDD_OUTPUT_FILE"; echo "--- End ntldd stdout ---"
    
        echo "--- Pipeline Debug ---"
        # Use a grep pattern matching the Windows-style path seen in ntldd output
        # Need double backslashes for literal backslash in grep pattern within double quotes
        # Using '/d/a/_temp/msys64/mingw64/bin/' might also work if ntldd normalizes sometimes
        # Let's try matching 'mingw64\\bin\\' literally first.
        GREP_PATTERN='mingw64\\bin\\'
        echo "Step 1: grep '${GREP_PATTERN}' ..."
        grep "${GREP_PATTERN}" "$NTLDD_OUTPUT_FILE" > "$STEP1_OUT"
        GREP1_EXIT_CODE=$?
        echo "  grep1 exit code: ${GREP1_EXIT_CODE}"
        # grep returns 1 if no lines match, we need lines to proceed
        if [ ${GREP1_EXIT_CODE} -eq 1 ]; then echo "  grep1 found no matching lines! Cannot extract DLLs."; exit 1; fi
        if [ ${GREP1_EXIT_CODE} -gt 1 ]; then echo "  grep1 failed!"; exit ${GREP1_EXIT_CODE}; fi
        echo "  grep1 output:" ; cat "$STEP1_OUT"; echo "  --- End grep1 output ---"
    
        echo "Step 2: awk '{print \$3}' ..." # Still assume path is field 3
        awk '{print $3}' "$STEP1_OUT" > "$STEP2_OUT"
        AWK_EXIT_CODE=$?
        echo "  awk exit code: ${AWK_EXIT_CODE}"
        if [ ${AWK_EXIT_CODE} -ne 0 ]; then echo "  awk failed!"; exit ${AWK_EXIT_CODE}; fi
        echo "  awk output:"; cat "$STEP2_OUT"; echo "  --- End awk output ---"
    
        echo "Step 3: grep -v Filter (Using placeholder, path comparison is tricky)..."
        # Filtering the EXE path might be unreliable now due to path format difference
        # Let's skip filtering the EXE for now and just copy it again later if needed
        # Alternatively, convert EXE_PATH to windows format first? Too complex for now.
        cp "$STEP2_OUT" "$STEP3_OUT" # Just copy for now
        GREP2_EXIT_CODE=0
        echo "  grep2 exit code: ${GREP2_EXIT_CODE} (Skipped actual filtering)"
        echo "  grep2 output (same as awk):"; cat "$STEP3_OUT"; echo "  --- End grep2 output ---"
    
        echo "Step 4: sort -u ..."
        sort -u "$STEP3_OUT" > "$STEP4_OUT"
        SORT_EXIT_CODE=$?
        echo "  sort exit code: ${SORT_EXIT_CODE}"
        if [ ${SORT_EXIT_CODE} -ne 0 ]; then echo "  sort failed!"; exit ${SORT_EXIT_CODE}; fi
        echo "  sort output (final list before writing):"; cat "$STEP4_OUT"; echo "  --- End sort output ---"
    
        # Write final list to DLL_LIST_FILE
        mv "$STEP4_OUT" "$DLL_LIST_FILE"
    
        echo "--- Final generated DLL list (${DLL_LIST_FILE}): ---"
        cat "$DLL_LIST_FILE" || echo "  (DLL list file empty or not found)"
        echo "--- End DLL List ---"
        echo "--- Pipeline finished. ---"
      id: deps

    # Step 7: Prepare artifact directory (Consolidated Copies)
    - name: Prepare artifact directory
      run: |
        INSTALL_DIR="/mingw64"        # Where ninja install put the files
        DEST_DIR="artifact"           # Directory to gather files for the artifact
        DLL_LIST_FILE="dll_list.txt"  # From step 6

        echo "Creating destination directories..."
        mkdir -p "${DEST_DIR}/bin"
        # Top-level lib, share, etc dirs will be created by cp -r as needed

        echo "Copying main executable..."
        cp --verbose "${INSTALL_DIR}/bin/gtk-crusader-village.exe" "${DEST_DIR}/bin/"

        echo "Copying gdbus executable..."
        cp --verbose "${INSTALL_DIR}/bin/gdbus.exe" "${DEST_DIR}/bin/" 2>/dev/null || echo "Warning: gdbus.exe not found."

        echo "Copying detected runtime DLLs to bin..."
        if [ -f "$DLL_LIST_FILE" ]; then
          while IFS= read -r dll_path; do
            if [ -f "$dll_path" ]; then
              dll_basename=$(basename "$dll_path")
              if [[ "$dll_basename" != "gtk-crusader-village.exe" && "$dll_basename" != "gdbus.exe" ]]; then
                 echo "Copying Dependency: $dll_path"
                 cp --verbose "$dll_path" "${DEST_DIR}/bin/"
              fi
            else
              echo "Warning: DLL listed by ntldd not found: $dll_path"
            fi
          done < "$DLL_LIST_FILE"
        else
          echo "Warning: ${DLL_LIST_FILE} not found. Cannot copy DLLs automatically."
        fi

        echo "Explicitly copying potentially missed DLLs (librsvg, etc.) to bin..."
        EXPLICIT_DLLS=( "librsvg-2" "libxml2" "libcroco" ) # Add others if needed
        for lib in "${EXPLICIT_DLLS[@]}"; do
          echo "Looking for explicit ${lib}*.dll in ${INSTALL_DIR}/bin/"
          find "${INSTALL_DIR}/bin/" -maxdepth 1 -name "${lib}*.dll" -print -exec cp -vt "${DEST_DIR}/bin/" {} + || echo "Info: Explicit DLL ${lib}*.dll not found."
        done

        # --- Consolidated Copying of lib/share/etc subdirectories ---
        echo "Recursively copying essential lib/share/etc directories..."

        # Copy GDK Pixbuf library files (loaders, cache are inside)
        if [ -d "${INSTALL_DIR}/lib/gdk-pixbuf-2.0" ]; then
          mkdir -p "${DEST_DIR}/lib" # Ensure base lib dir exists
          cp -r --verbose "${INSTALL_DIR}/lib/gdk-pixbuf-2.0" "${DEST_DIR}/lib/"
        else
          echo "Warning: Source directory ${INSTALL_DIR}/lib/gdk-pixbuf-2.0 not found."
        fi

        # Copy GSettings schemas (compiled + source are inside)
        if [ -d "${INSTALL_DIR}/share/glib-2.0" ]; then
          mkdir -p "${DEST_DIR}/share" # Ensure base share dir exists
          cp -r --verbose "${INSTALL_DIR}/share/glib-2.0" "${DEST_DIR}/share/"
        else
          echo "Warning: Source directory ${INSTALL_DIR}/share/glib-2.0 not found."
        fi

        # Copy ALL icon themes (hicolor, Adwaita, app-specific are inside)
        if [ -d "${INSTALL_DIR}/share/icons" ]; then
          mkdir -p "${DEST_DIR}/share"
          cp -r --verbose "${INSTALL_DIR}/share/icons" "${DEST_DIR}/share/"
        else
          echo "Warning: Source directory ${INSTALL_DIR}/share/icons not found."
        fi

        # Copy ALL locale data
        if [ -d "${INSTALL_DIR}/share/locale" ]; then
          mkdir -p "${DEST_DIR}/share"
          cp -r --verbose "${INSTALL_DIR}/share/locale" "${DEST_DIR}/share/"
        else
          echo "Warning: Source directory ${INSTALL_DIR}/share/locale not found."
        fi

        # Copy GTK settings directory
        if [ -d "${INSTALL_DIR}/etc/gtk-4.0" ]; then
          mkdir -p "${DEST_DIR}/etc" # Ensure base etc dir exists
          cp -r --verbose "${INSTALL_DIR}/etc/gtk-4.0" "${DEST_DIR}/etc/"
        else
          echo "Warning: Source directory ${INSTALL_DIR}/etc/gtk-4.0 not found."
        fi

        # Copy other specific application data directories if needed (example)
        # if [ -d "${INSTALL_DIR}/share/my-app-data" ]; then
        #    mkdir -p "${DEST_DIR}/share"
        #    cp -r --verbose "${INSTALL_DIR}/share/my-app-data" "${DEST_DIR}/share/"
        # fi

        # Copy specific remaining files if not covered by directory copies
        # (Metainfo, Desktop, Service files are usually needed individually for installers/system integration,
        # but for a simple zip package, having them inside the copied share/ folder might be sufficient)
        echo "Copying specific metadata files (metainfo, desktop, service)..."
        mkdir -p "${DEST_DIR}/share/metainfo"
        cp --verbose "${INSTALL_DIR}/share/metainfo/"*.xml "${DEST_DIR}/share/metainfo/" 2>/dev/null || echo "Warning: metainfo file not found."
        mkdir -p "${DEST_DIR}/share/applications"
        cp --verbose "${INSTALL_DIR}/share/applications/"*.desktop "${DEST_DIR}/share/applications/" 2>/dev/null || echo "Warning: .desktop file not found."
        mkdir -p "${DEST_DIR}/share/dbus-1/services"
        cp --verbose "${INSTALL_DIR}/share/dbus-1/services/"*.service "${DEST_DIR}/share/dbus-1/services/" 2>/dev/null || echo "Warning: .service file not found."


        echo "--- Finished preparing artifact directory ---"

    # Step 8: Upload the artifact (action zips the directory)
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: gtk-crusader-village-windows-x64
        path: artifact # Upload the contents of the 'artifact' directory

    # Optional: Create Release and Upload Asset (uncomment and adapt if you use tags for releases)
    # - name: Create Release
    #   if: startsWith(github.ref, 'refs/tags/')
    #   id: create_release
    #   uses: actions/create-release@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     tag_name: ${{ github.ref_name }}
    #     release_name: Release ${{ github.ref_name }}
    #     draft: false
    #     prerelease: false # Set to true if it's a pre-release
    #
    # - name: Upload Release Asset
    #   if: startsWith(github.ref, 'refs/tags/')
    #   uses: actions/upload-release-asset@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     upload_url: ${{ steps.create_release.outputs.upload_url }}
    #     asset_path: ./gtk-crusader-village-windows-x64.zip
    #     asset_name: gtk-crusader-village-windows-x64.zip
    #     asset_content_type: application/zip
