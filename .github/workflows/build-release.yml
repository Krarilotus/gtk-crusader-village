# .github/workflows/windows-build.yml
# Builds on Windows using MSYS2, automatically detects DLL dependencies using ntldd,
# packages artifacts, and uploads.

name: Build Windows Release

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build-windows:
    runs-on: windows-latest
    defaults:
      run:
        shell: msys2 {0}

    steps:
    # Step 1: Checkout repository
    - name: Checkout repository
      uses: actions/checkout@v4
      # with:
      #   submodules: 'recursive'

    # Step 2: Set up MSYS2 environment & Install Dependencies
    - name: Set up MSYS2
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: >-
          git
          mingw-w64-x86_64-toolchain
          mingw-w64-x86_64-meson
          mingw-w64-x86_64-ninja
          mingw-w64-x86_64-python
          mingw-w64-x86_64-pkgconf
          mingw-w64-x86_64-gtk4
          mingw-w64-x86_64-libadwaita
          mingw-w64-x86_64-json-glib
          mingw-w64-x86_64-gettext
          mingw-w64-x86_64-desktop-file-utils
          mingw-w64-x86_64-appstream
          mingw-w64-x86_64-ntldd

    # Step 3: Configure build
    - name: Configure build
      run: meson setup build --prefix=/mingw64 --buildtype=release

    # Step 4: Compile project
    - name: Compile project
      run: ninja -C build

    # Step 5: Install project
    - name: Install project
      # Let the workflow fail if installation fails (removed || echo)
      run: ninja -C build install

    # Step 6: Analyze Dependencies using ntldd (with Pipeline Debugging)
    - name: Analyze Dependencies
      run: |
        EXE_PATH="/mingw64/bin/gtk-crusader-village.exe"
        DLL_LIST_FILE="dll_list.txt"
        NTLDD_OUTPUT_FILE="ntldd_output.log"
        NTLDD_ERROR_FILE="ntldd_error.log"
        # Intermediate files for pipeline steps
        STEP1_OUT="pipe_step1.log"
        STEP2_OUT="pipe_step2.log"
        STEP3_OUT="pipe_step3.log"
        STEP4_OUT="pipe_step4.log" # This is the final list before writing to file

        echo "--- Debugging ntldd & Pipeline ---"
        echo "Checking if executable exists at ${EXE_PATH}:"
        ls -l "$EXE_PATH" || { echo "*** EXECUTABLE ${EXE_PATH} not found! ***"; exit 1; } # Exit if exe missing

        echo "Attempting to run ntldd -R ${EXE_PATH}..."
        ntldd -R "$EXE_PATH" > "$NTLDD_OUTPUT_FILE" 2> "$NTLDD_ERROR_FILE"
        NTLDD_EXIT_CODE=$?
        echo "ntldd exit code: ${NTLDD_EXIT_CODE}"
        # Printing stderr first in case of subtle errors
        echo "--- ntldd stderr (${NTLDD_ERROR_FILE}): ---"; cat "$NTLDD_ERROR_FILE" || echo "  (No stderr)"; echo "--- End ntldd stderr ---"
        # Print stdout only if command succeeded, otherwise it might be empty/irrelevant
        if [ ${NTLDD_EXIT_CODE} -eq 0 ]; then
          echo "--- ntldd stdout (${NTLDD_OUTPUT_FILE}): ---"; cat "$NTLDD_OUTPUT_FILE"; echo "--- End ntldd stdout ---"
        else
          echo "ntldd command failed. Exiting."
          exit ${NTLDD_EXIT_CODE}
        fi

        echo "--- Pipeline Debug ---"

        echo "Step 1: grep '/mingw64/bin/' ..."
        grep '/mingw64/bin/' "$NTLDD_OUTPUT_FILE" > "$STEP1_OUT"
        GREP1_EXIT_CODE=$?
        echo "  grep1 exit code: ${GREP1_EXIT_CODE}"
        # grep returns 1 if no lines match, which is not a fatal error for the pipeline
        if [ ${GREP1_EXIT_CODE} -gt 1 ]; then echo "  grep1 failed!"; exit ${GREP1_EXIT_CODE}; fi
        echo "  grep1 output:" ; cat "$STEP1_OUT"; echo "  --- End grep1 output ---"

        echo "Step 2: awk '{print \$3}' ..." # Need to escape $ for awk within double quotes
        awk '{print $3}' "$STEP1_OUT" > "$STEP2_OUT"
        AWK_EXIT_CODE=$?
        echo "  awk exit code: ${AWK_EXIT_CODE}"
        if [ ${AWK_EXIT_CODE} -ne 0 ]; then echo "  awk failed!"; exit ${AWK_EXIT_CODE}; fi
        echo "  awk output:"; cat "$STEP2_OUT"; echo "  --- End awk output ---"

        echo "Step 3: grep -v \"$EXE_PATH\" ..." # Use double quotes for variable expansion
        grep -v "$EXE_PATH" "$STEP2_OUT" > "$STEP3_OUT"
        GREP2_EXIT_CODE=$?
        echo "  grep2 exit code: ${GREP2_EXIT_CODE}"
        # grep exits 1 if no lines selected (i.e., exe path wasn't found), which is OK
        if [ ${GREP2_EXIT_CODE} -gt 1 ]; then echo "  grep2 failed!"; exit ${GREP2_EXIT_CODE}; fi
        echo "  grep2 output:"; cat "$STEP3_OUT"; echo "  --- End grep2 output ---"

        echo "Step 4: sort -u ..."
        sort -u "$STEP3_OUT" > "$STEP4_OUT"
        SORT_EXIT_CODE=$?
        echo "  sort exit code: ${SORT_EXIT_CODE}"
        if [ ${SORT_EXIT_CODE} -ne 0 ]; then echo "  sort failed!"; exit ${SORT_EXIT_CODE}; fi
        echo "  sort output (final list before writing):"; cat "$STEP4_OUT"; echo "  --- End sort output ---"

        # Write final list to DLL_LIST_FILE
        mv "$STEP4_OUT" "$DLL_LIST_FILE"

        echo "--- Final generated DLL list (${DLL_LIST_FILE}): ---"
        cat "$DLL_LIST_FILE" || echo "  (DLL list file empty or not found)"
        echo "--- End DLL List ---"
        echo "--- Pipeline appears successful. ---"
      id: deps

    # Step 7: Prepare artifact directory using dynamic DLL list
    - name: Prepare artifact directory
      run: |
        INSTALL_DIR="/mingw64"
        DEST_DIR="artifact"
        DLL_LIST_FILE="dll_list.txt" # File containing needed DLL paths from previous step

        echo "Creating destination directories..."
        mkdir -p "${DEST_DIR}/bin"
        mkdir -p "${DEST_DIR}/share/icons/hicolor/scalable/apps"
        mkdir -p "${DEST_DIR}/share/icons/hicolor/symbolic/apps"
        mkdir -p "${DEST_DIR}/share/glib-2.0/schemas"
        mkdir -p "${DEST_DIR}/share/locale"
        mkdir -p "${DEST_DIR}/share/metainfo"
        mkdir -p "${DEST_DIR}/share/applications"
        mkdir -p "${DEST_DIR}/share/dbus-1/services"

        echo "Copying executable..."
        cp --verbose "${INSTALL_DIR}/bin/gtk-crusader-village.exe" "${DEST_DIR}/bin/"

        echo "Copying detected DLLs from ${DLL_LIST_FILE}..."
        if [ -f "$DLL_LIST_FILE" ]; then
          while IFS= read -r dll_path; do
            if [ -f "$dll_path" ]; then
              echo "Copying $dll_path"
              cp --verbose "$dll_path" "${DEST_DIR}/bin/"
            else
              echo "Warning: DLL listed by ntldd not found: $dll_path"
            fi
          done < "$DLL_LIST_FILE"
        else
          echo "Warning: ${DLL_LIST_FILE} not found. Cannot copy DLLs automatically."
        fi

        # --- Copying data files (remains the same) ---
        echo "Copying data files..."
        cp --verbose "${INSTALL_DIR}/share/glib-2.0/schemas/"*.xml "${DEST_DIR}/share/glib-2.0/schemas/" 2>/dev/null || echo "Warning: gschema files not found."
        cp --verbose "${INSTALL_DIR}/share/icons/hicolor/scalable/apps/"*.svg "${DEST_DIR}/share/icons/hicolor/scalable/apps/" 2>/dev/null || echo "Warning: Scalable icon not found."
        cp --verbose "${INSTALL_DIR}/share/icons/hicolor/symbolic/apps/"*.svg "${DEST_DIR}/share/icons/hicolor/symbolic/apps/" 2>/dev/null || echo "Warning: Symbolic icon not found."
        cp --verbose "${INSTALL_DIR}/share/metainfo/"*.xml "${DEST_DIR}/share/metainfo/" 2>/dev/null || echo "Warning: metainfo file not found."
        cp --verbose "${INSTALL_DIR}/share/applications/"*.desktop "${DEST_DIR}/share/applications/" 2>/dev/null || echo "Warning: .desktop file not found."
        cp --verbose "${INSTALL_DIR}/share/dbus-1/services/"*.service "${DEST_DIR}/share/dbus-1/services/" 2>/dev/null || echo "Warning: .service file not found."

        echo "Copying locale files..."
        if [ -d "${INSTALL_DIR}/share/locale" ]; then
          for langdir in "${INSTALL_DIR}"/share/locale/*; do
            lang=$(basename "$langdir")
            if [[ "$lang" =~ ^[a-z]{2}(_[A-Z]{2})?$ ]]; then
              if [ -f "$langdir/LC_MESSAGES/gtk-crusader-village.mo" ]; then
                mkdir -p "${DEST_DIR}/share/locale/$lang/LC_MESSAGES"
                cp "$langdir/LC_MESSAGES/gtk-crusader-village.mo" "${DEST_DIR}/share/locale/$lang/LC_MESSAGES/"
              fi
            fi
          done
        fi
        # --- End copying data files ---

    # Step 8: Upload the artifact (action zips the directory)
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: gtk-crusader-village-windows-x64
        path: artifact # Upload the contents of the 'artifact' directory

    # Optional: Create Release and Upload Asset (uncomment and adapt if you use tags for releases)
    # - name: Create Release
    #   if: startsWith(github.ref, 'refs/tags/')
    #   id: create_release
    #   uses: actions/create-release@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     tag_name: ${{ github.ref_name }}
    #     release_name: Release ${{ github.ref_name }}
    #     draft: false
    #     prerelease: false # Set to true if it's a pre-release
    #
    # - name: Upload Release Asset
    #   if: startsWith(github.ref, 'refs/tags/')
    #   uses: actions/upload-release-asset@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     upload_url: ${{ steps.create_release.outputs.upload_url }}
    #     asset_path: ./gtk-crusader-village-windows-x64.zip
    #     asset_name: gtk-crusader-village-windows-x64.zip
    #     asset_content_type: application/zip
